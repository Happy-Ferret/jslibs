/* ***** BEGIN LICENSE BLOCK *****
 * Version: GNU GPL 2.0
 *
 * The contents of this file are subject to the
 * GNU General Public License Version 2.0; you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * ***** END LICENSE BLOCK ***** */

#include "stdafx.h"
#include "../jslang/handlePub.h"
#include "../jslang/blobPub.h"
#include "jslang.h"


DECLARE_CLASS(Handle)


/**doc fileIndex:topmost **/

/**doc
$CLASS_HEADER
$SVN_REVISION $Revision$
**/
BEGIN_STATIC

/**doc
=== Static functions ==
**/



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**doc
$TOC_MEMBER $INAME
 $BOOL $INAME()
  Returns $TRUE if the value is callable (either a function or a callable object).
  $H example
  {{{
  var md5 = new Hash('md5');

  print( isCallable(md5) ) // prints true
  print( typeof(md5) == 'function' ) // prints false
  
  // md5 can be called even if it is not a function.
  print( hexEncode( md5('foobar') ) ); // prints: 3858F62230AC3C915F300C664312C63F
  }}}
**/
/**qa
	loadModule('jscrypt');
	QA.ASSERT( isCallable(new Hash('md5')), true );
	QA.ASSERT( isCallable(function()0), true );
**/

ADD_DOC(isCallable, "boolean isCallable(value)", "returns true if the value can be called like a function");

DEFINE_FUNCTION( isCallable ) {

	JL_DEFINE_ARGS;
	JL_ASSERT_ARGC(1);

	JL_RVAL.setBoolean( jl::isCallable(cx, JL_ARG(1)) );
	return true;
	JL_BAD;
}


/**doc
$TOC_MEMBER $INAME
 $STR $INAME( value [, toArrayBuffer] )
  This function converts any value or stream into a string.
  If _toArrayBuffer_ is given and is true, the result is stored into an ArrayBuffer.
  The _value_ argument may be: StreamRead compatible object, any kind of data value (string, TypedArray, ...)
**/
/**qa
	QA.ASSERTOP( stringify(), '==', undefined );
	QA.ASSERTOP( stringify(undefined), '==', undefined );
	QA.ASSERTOP( stringify('str'), '==', 'str' );
	QA.ASSERTOP( stringify('str', false), 'typeof', 'string' );
	QA.ASSERTOP( stringify('str', true), 'instanceof', ArrayBuffer );
	QA.ASSERTOP( stringify(stringify(stringify(stringify(stringify('abcd'), true)), true)), '===', 'abcd' );
	QA.ASSERTOP( stringify(Uint16Array(stringify('\x00\x01\x02\x03', true))), '===', '\u0100\u0302' ); // endian issue ?
**/

ADD_DOC(stringify, "string|ArrayBuffer stringify(value [, toArrayBuffer])", "convert a value to a string or an ArrayBuffer");

DEFINE_FUNCTION( stringify ) {

	JL_DEFINE_ARGS;
	JLData str;

	if ( JL_ARGC == 1 && JL_ARG(1).isString() ) { // identity
		
		JL_RVAL.set(JL_ARG(1));
		return true;
	}

	if ( JL_ARGC == 0 || (JL_ARGC == 1 && JL_ARG(1).isUndefined()) ) { // preserve undefined

		JL_RVAL.setUndefined();
		return true;
	}

	bool toArrayBuffer;
	if ( JL_ARG_ISDEF(2) )
		JL_CHK( jl::getValue(cx, JL_ARG(2), &toArrayBuffer) );
	else
		toArrayBuffer = false;

	if ( JL_ARG(1).isObject() ) {

		JS::RootedObject sobj(cx, &JL_ARG(1).toObject() );

		NIStreamRead read = StreamReadInterface(cx, sobj);
		if ( read ) {

			jl::ChunkedBuffer<char> buf;

			size_t length;
			do {

				length = 4096;
				buf.Reserve(4096);
				JL_CHK( read(cx, sobj, buf.Ptr(), &length) );
				buf.Advance(length);
			} while ( length != 0 );

			if ( toArrayBuffer ) {

				//JL_CHK( JL_NewBufferGetOwnership(cx, buf.GetDataOwnership(), buf.Length(), JL_RVAL) );
				JL_CHK( BlobCreate(cx, buf.GetDataOwnership(), buf.Length(), JL_RVAL) );
			} else {

				JSString *jsstr = JS_NewStringCopyN(cx, buf.GetData(), buf.Length());
				JL_CHK( jsstr );
				JL_RVAL.setString(jsstr);
			}

			return true;
		}

	}

	// fallback:
	JL_CHK( jl::getValue(cx, JL_ARG(1), &str) );
	JL_CHK( toArrayBuffer ? str.GetArrayBuffer(cx, JL_RVAL) : str.GetJSString(cx, JL_RVAL) );

	return true;
	JL_BAD;
}



/**doc
$TOC_MEMBER $INAME
 $STR $INAME( iterableObject [, toArrayBuffer] )
  Joins data generated by iterating the _iterableObject_ value.
 The _iterableObject_ may be arrays, array-like objects, iterators and generators.
 If _toArrayBuffer_ is given and is true, the result is stored into an ArrayBuffer instead of a string.
**/
/**qa
	QA.ASSERT(join([1,2,3,4,5]), '12345');
	QA.ASSERT(join([stringify('abc', true), stringify('def', true)]), 'abcdef');
	QA.ASSERT(join([]), '');
	QA.ASSERT(join(Iterator([0,0,0], true)), '012');
	QA.ASSERT(join((function() {yield ''; yield 'a'; yield 'bc'; yield ''; yield 'def'; yield 'g' })()) , 'abcdefg');
	
	QA.ASSERTOP( join((function() {yield})()), '===', 'undefined');
	
	var a = 'abcd';
	var it = {
		next: function() {
			delete this.next; // has no effect
			a = a.substr(1);
			if ( !a )
				throw StopIteration;
			return a[0];
		}
	};
	QA.ASSERTOP( join(it), '==', 'bcd');
	QA.ASSERTOP( stringify(stringify('123456789', true).slice(3)), '==', '456789');
**/
ADD_DOC( join, "string|ArrayBuffer join(iterableObject [,toArrayBuffer])", "joins data" )
DEFINE_FUNCTION( join ) {

	JL_DEFINE_ARGS;

	JS::AutoValueVector avr(cx);
	avr.reserve(16);

	jl::Stack<JLData, jl::StaticAllocMedium> strList;
	size_t length = 0;

	JS::RootedValue val(cx);

	JL_ASSERT_ARGC_MIN(1);
	JL_ASSERT_ARG_IS_OBJECT(1);

	{

	JS::RootedObject argObj(cx, &JL_ARG(1).toObject());

	if ( jl::isArrayLike(cx, argObj) ) {

		uint32_t arrayLen;
		JL_CHK( JS_GetArrayLength(cx, argObj, &arrayLen) );
		for ( unsigned i = 0; i < arrayLen; ++i ) {

			JL_CHK( JL_GetElement(cx, argObj, i, &val) );
			JL_CHK( jl::getValue(cx, val, &*++strList) );
			length += strList->Length();
			avr.append(val);
		}
	} else {

		JS::RootedValue nextFct(cx);
		JL_CHK( JS_GetPropertyById(cx, argObj, JLID(cx, next), &nextFct) );
		JL_ASSERT_IS_CALLABLE(nextFct, "iterator");
		while ( JS_CallFunctionValue(cx, argObj, nextFct, JS::HandleValueArray::empty(), &val) != false ) { // loop until StopIteration or error

			JL_CHK( jl::getValue(cx, val, &*++strList) );
			length += strList->Length();
			avr.append(val);
		}
		JL_CHK( jl::isStopIterationExceptionPending(cx) );
		JS_ClearPendingException(cx);
	}

	bool toArrayBuffer;
	if ( JL_ARG_ISDEF(2) )
		JL_CHK( jl::getValue(cx, JL_ARG(2), &toArrayBuffer) );
	else
		toArrayBuffer = false;

	if ( toArrayBuffer ) {

		jl::AutoBuffer buffer;
		
		//uint8_t *buf = JL_NewBuffer(cx, length, JL_RVAL);
		//JL_CHK( buf );

		buffer.alloc(length);
		JL_ASSERT_ALLOC(buffer);
		
		//buf += length;
		uint8_t *buf;
		buf = buffer.data() + length;

		while ( strList ) {

			buf -= strList->Length();
			strList->CopyTo(buf);
			--strList;
		}

		JL_CHK( BlobCreate(cx, buffer, JL_RVAL) );

	} else {

		jschar *buf = (jschar*)JS_malloc(cx, (length +1) * sizeof(jschar));
		buf += length;
		*buf = 0; // required by JL_NewUCString

		while ( strList ) {

			buf -= strList->Length();
			strList->CopyTo(buf);
			--strList;
		}

		JSString *jsstr = JL_NewUCString(cx, buf, length);
		JL_ASSERT( jsstr != NULL, E_VALUE, E_CONVERT, E_TY_STRING );
		JL_RVAL.setString(jsstr);
	}

	}

	return true;
	JL_BAD;
}



/**doc
$TOC_MEMBER $INAME
 $STR $INAME( data, pattern [, startIndex = 0] )
**/

ADD_DOC( indexOf, "string|ArrayBuffer indexOf(data, pattern [,startIndex = 0])", "" );
DEFINE_FUNCTION( indexOf ) {

	JL_DEFINE_ARGS;

	JLData srcStr, patStr;
	uint32_t start;
	
	JL_ASSERT_ARGC_MIN(2);

	JL_CHK( jl::getValue(cx, JL_ARG(1), &srcStr) );
	JL_CHK( jl::getValue(cx, JL_ARG(2), &patStr) );

	if ( JL_ARG_ISDEF(3) ) {

		JL_CHK( jl::getValue(cx, JL_ARG(3), &start) );
		if ( start > srcStr.Length() - patStr.Length() ) {
			
			JL_RVAL.setInt32(-1);
			return true;
		}
	} else {
	
		start = 0;
	}

	if ( srcStr.IsWide() )
		JL_RVAL.setInt32( jl::Match(srcStr.GetConstWStr()+start, srcStr.Length()-start, patStr.GetConstWStr(), patStr.Length()) );
	else
		JL_RVAL.setInt32( jl::Match(srcStr.GetConstStr()+start, srcStr.Length()-start, patStr.GetConstStr(), patStr.Length()) );

	return true;
	JL_BAD;
}



/**doc
$TOC_MEMBER $INAME
 $INT $INAME( eventsHandler1 [, ... [, eventsHandler30]] )
  Passive event waiting.
  Returns the bit field that represents the index (in arguments order) of the triggered events. eg. if eventsHandler1 event is triggered, bit 1 is set.
  $H note
   Calling processEvents() with no argument jsut returns 0.
  $H example 1
{{{
loadModule('jsstd');

function onTimeout() {

  print('.');
}

function onEndSignal() {

  print('end signal detected\n');
  throw 0;
}

for (;;) {

  processEvents( timeoutEvents(500, onTimeout), host.endSignalEvents(onEndSignal) );
}
}}}

  $H example 2
{{{
function mySleep(timeout) {

	processEvents( timeoutEvents(timeout) );
}
}}}
**/
JLThreadFuncDecl
ProcessEventThread( void *data ) {

	ProcessEventThreadInfo *ti = static_cast<ProcessEventThreadInfo*>(data);
	int st;
	for (;;) {

		st = JLSemaphoreAcquire(ti->startSem);
		ASSERT(st);
		if ( ti->isEnd )
			break;
		ASSERT( ti != NULL );
		ASSERT( ti->peSlot != NULL );
//		ASSERT( ti->peSlot->startWait != NULL );
		ti->peSlot->startWait();
		ti->peSlot = NULL;
		JLSemaphoreRelease(ti->signalEventSem);
	}
	return 0;
}

DEFINE_FUNCTION( processEvents ) {

	JL_DEFINE_ARGS;
	int st;

	ModulePrivate *mpv = (ModulePrivate*)jl::Host::getHost(cx).moduleManager().modulePrivate(jslangModuleId);

	ASSERT( JLSemaphoreOk(mpv->processEventSignalEventSem) );

	JS::RootedObject handleObj(cx);

	JL_ASSERT_ARGC_MAX( COUNTOF(mpv->processEventThreadInfo) );
	
	ProcessEvent2 *peList[COUNTOF(mpv->processEventThreadInfo)]; // cache to avoid calling GetHandlePrivate() too often.

	if ( JL_ARGC == 0 ) {
		
		JL_RVAL.setInt32(0);
		return true;
	}

	// fill peList slots
	unsigned int i;
	for ( i = 0; i < argc; ++i ) {

		handleObj.set(&JL_ARG(i+1).toObject());
		JL_ASSERT_ARG_TYPE( IsHandle(cx, handleObj), i+1, "(pev) Handle" );
		JL_ASSERT_ARG_TYPE( IsHandleType(cx, handleObj, JLHID(pev)), i+1, "(pev) Handle" );
		
		ProcessEvent2 *pe;
		JL_CHK( GetHandlePrivate(cx, handleObj, pe) );
		JL_ASSERT( pe != NULL, E_ARG, E_NUM(i+1), E_STATE ); //JL_ASSERT( pe != NULL, E_ARG, E_NUM(i+1), E_ANINVALID, E_NAME("pev Handle") );

		JL_CHK( pe->prepareWait(cx, handleObj) );

		peList[i] = pe;
	}

	// prepare threads
	for ( i = 0; i < argc; ++i ) {

		ProcessEventThreadInfo *ti = &mpv->processEventThreadInfo[i];

		if ( ti->startSem == 0 ) {

			ti->startSem = JLSemaphoreCreate(0);
			ASSERT( JLSemaphoreOk(ti->startSem) );
		}
		
		if ( ti->thread == 0 ) { // create the thread stuff, see jl_cmalloc in jslangModuleInit()

			ti->thread = JLThreadStart(ProcessEventThread, ti);

			if ( !JLThreadOk(ti->thread) )
				return JL_ThrowOSError(cx);

			ASSERT( JLThreadOk(ti->thread) );
			JLThreadPriority(ti->thread, JL_THREAD_PRIORITY_HIGHEST);
			ti->signalEventSem = mpv->processEventSignalEventSem;
			ti->isEnd = false;
		}

		ASSERT( ti->peSlot == NULL );
		ASSERT( ti->isEnd == false );

		ti->peSlot = peList[i];
		JLSemaphoreRelease(ti->startSem);
	}

	// wait !

//	JS_EndRequest(cx);
	JLSemaphoreAcquire(mpv->processEventSignalEventSem); // wait for an event (timeout can also be managed here)
	JLSemaphoreRelease(mpv->processEventSignalEventSem);
//	JS_BeginRequest(cx);

	// cancel other waits
	for ( i = 0; i < argc; ++i ) {

		/*volatile*/ ProcessEvent2 *peSlot = mpv->processEventThreadInfo[i].peSlot; // avoids to mutex ti->peSlot access.
		if ( peSlot != NULL ) { // see ProcessEventThread(). if peSlot is null this mean that peSlot->startWait() has returned.

			if ( !peSlot->cancelWait() ) { // if the thread cannot be gracefully canceled then kill it. However, keep the signalEventSem semaphore (no JLSemaphoreFree(&ti->startSem)).

				ProcessEventThreadInfo *ti = &mpv->processEventThreadInfo[i];
				ti->peSlot = NULL;
				JLSemaphoreRelease(ti->signalEventSem); // see ProcessEventThread()
				JLThreadCancel(ti->thread);
				JLThreadWait(ti->thread); // (TBD) needed ?
				JLThreadFree(&ti->thread);
				ti->thread = 0; // mean that "the thread is free/unused" (see thread creation place)
			}
		}
	}

	for ( i = 0; i < argc; ++i ) {

		st = JLSemaphoreAcquire(mpv->processEventSignalEventSem);
		ASSERT( st );
	}

	ASSERT( argc <= JSVAL_INT_BITS ); // bits

	int32_t eventsMask;
	eventsMask = 0;
	bool hasEvent;
	bool ok;
	ok = true;

	// notify waiters
	for ( i = 0; i < argc; ++i ) {

		ProcessEvent2 *pe = peList[i];

		JSExceptionState *exState = NULL;
		if ( JL_IsExceptionPending(cx) ) {

			exState = JS_SaveExceptionState(cx);
			JS_ClearPendingException(cx);
		}

		handleObj.set(&JL_ARG(i+1).toObject());
		if ( pe->endWait(&hasEvent, cx, handleObj) != true )
			ok = false; // report errors later

		if ( exState )
			JS_RestoreExceptionState(cx, exState);

		if ( hasEvent )
			eventsMask |= 1 << i;

//		JL_CHK( HandleClose(cx, JL_ARGV[i]) ); // (TBD) recycle items instead of closing them ?
	}

#ifdef DEBUG
	for ( i = 0; i < argc; ++i )
		ASSERT( mpv->processEventThreadInfo[i].peSlot == NULL );
	ASSERT( JLSemaphoreAcquire(mpv->processEventSignalEventSem, 0) == JLTIMEOUT ); // else invalid state
#endif // DEBUG

	JL_RVAL.setInt32(eventsMask);
	return ok;
	JL_BAD;
}




/**doc
$TOC_MEMBER $INAME
 $TYPE id $INAME( msTimeout [, onTimeout] )
 Passively waits for a timeout through the processEvents function.
**/
/**qa
	QA.ASSERTOP( timeoutEvents(0), 'instanceof', Handle );
	QA.ASSERTOP( timeoutEvents(0), '==', '[Handle  pev]' );
	QA.ASSERTOP( processEvents(timeoutEvents(0)), '===', 1 );
	QA.ASSERTOP( function() timeoutEvents(undefined), 'ex', RangeError );
	QA.ASSERTOP( function() timeoutEvents(-1), 'ex', RangeError );
	var d = Date.now();
	processEvents(timeoutEvents(123));
	d = Date.now() - d;
	QA.ASSERTOP( d, '>=', 123 -5); // error margin
	QA.ASSERTOP( d, '<=', 123 +10); // error margin
**/
class TimeoutProcessEvent : public ProcessEvent2 {
public:
	unsigned int timeout;
	JLEventHandler cancel;
	bool canceled;

	TimeoutProcessEvent(unsigned int timeout)
	: timeout(timeout) {

		cancel = JLEventCreate(false);
		ASSERT( JLEventOk(cancel) );
	}

	bool prepareWait(JSContext *cx, JS::HandleObject obj) {
		
		return true;
	}

	void startWait() {

		if ( timeout != 0 ) {

			int st = JLEventWait(cancel, timeout);
			canceled = (st == JLOK);
		} else {

			canceled = false;
		}
	}

	bool cancelWait() {

		JLEventTrigger(cancel);
		return true;
	}

	bool endWait(bool *hasEvent, JSContext *cx, JS::HandleObject obj) {

		JL_IGNORE(obj);

		*hasEvent = !canceled;

		// not triggered, then nothing to reset
		if ( !*hasEvent )
			return true;

		// reset for further use.
		JLEventReset(cancel);
		canceled = false;

		if ( slot(0) != JL_ZInitValue() ) {
		
			JS::RootedObject callThisObj(cx);
			callThisObj.set(&slot(1).toObject());
			JS::Value rval; // rval is unused then there is no need to root it
			JL_CHK( JS_CallFunctionValue(cx, callThisObj, hslot(0), JS::HandleValueArray::empty(), JS::MutableHandleValue::fromMarkedLocation(&rval)) );
		}

		return true;
		JL_BAD;
	}

	~TimeoutProcessEvent() {

		JLEventFree(&cancel);
	}
};



DEFINE_FUNCTION( timeoutEvents ) {

	JL_DEFINE_ARGS;
	JL_ASSERT_ARGC_RANGE(1, 2);

	uint32_t timeout;
	JL_CHK( jl::getValue(cx, JL_ARG(1), &timeout) );

	TimeoutProcessEvent *upe = new TimeoutProcessEvent(timeout);
	JL_CHK( HandleCreate(cx, upe, JL_RVAL) );
	if ( JL_ARG_ISDEF(2) ) {

		JL_ASSERT_ARG_IS_CALLABLE(2);
		upe->slot(0) = JL_ARG(2);
		upe->slot(1) = JL_OBJVAL;
	}

	return true;
	JL_BAD;
}


#if defined(DEBUG) // || 1
#define HAS_JL_API_TESTS
#endif


#ifdef HAS_JL_API_TESTS

#if !DEBUG
#pragma message ( "WARNING: test API available in non-debug mode !" )
#endif

#define TEST(expr) \
	( (expr) ? (void)0 : JL_AssertFailure(#expr, JL_CODE_LOCATION) )


/**qa
	if ( typeof _jsapiTests != 'undefined' )
		_jsapiTests();
**/

S_ASSERT(sizeof(wchar_t) == sizeof(jschar));

DEFINE_FUNCTION( _jsapiTests ) {

	JL_IGNORE(cx, argc, vp);

	void *contents = JS_AllocateArrayBufferContents(cx, 1000);
	
	JL_IGNORE(contents);

	return true;



/*
	JS::Value val = JS::Value();

	ASSERT(val.isDouble());
	ASSERT(val.asRawBits() == 0);
	val.setDouble(0);
	ASSERT(val.asRawBits() == 0);
*/




/*

	// allocators ////////////////////////////////////////////////////

	void *tmp1 = jl_malloc(100000);
	js_free(tmp1);

	void *tmp2 = js_malloc(100000);
	jl_free(tmp2);

	{
	void * ptr = jl_malloc(2);
	void * ptr2 = jl_realloc(ptr, 4);
	jl_free(ptr2);
	}


	/////////////////////////////////////////////////////////////////

	// Data issues //////////////////////////////////////////////////

	JLData dat1("0123456789", false, 10);
	
	const char *sd1 = dat1.GetConstStrZ();
	const char *sd2 = dat1.GetConstStrZ();

	TEST( sd1 == sd2 );

	/////////////////////////////////////////////////////////////////

	// Data issues 2 ////////////////////////////////////////////////
	{
	JLData path;
	JS::RootedValue tmp(cx, JSVAL_ONE);
	JL_CHK( jl::getValue(cx, tmp, &path) );
	const char *d1 = path.GetConstStrZ();
	const char *d2 = path.GetConstStrZ();
	TEST( d1 == d2 );
	}

	/////////////////////////////////////////////////////////////////

	TEST( JSVAL_IS_PRIMITIVE(JSVAL_NULL) );

	///////////////////////////////////////////////////////////////
	// check JL_JsvalToJsid -> JL_JsidToJsval
	//
	JS::RootedObject o(cx, JL_NewObj(cx));
	JS::RootedId id(cx);
	JS::RootedValue s(cx);
	s.setObject(*o);

	TEST( JL_JsvalToJsid(cx, s, &id) );
	TEST( JSID_IS_OBJECT(id) );
	JS::RootedValue r(cx);
	TEST( JL_JsidToJsval(cx, id, &r) );
	TEST( JSVAL_TO_OBJECT(r) == o );

	TEST( JS_ValueToId(cx, OBJECT_TO_JSVAL(o), &id) );
	TEST( !JSID_IS_OBJECT(id) );

	bool found;
	TEST( JS_DefineProperty(cx, o, "test", JSVAL_ONE, NULL, NULL, JSPROP_PERMANENT) );
	TEST( JS_HasProperty(cx, o, "test", &found) );
	TEST( found );

	JSString *jsstr = JS_NewUCStringCopyZ(cx, L("testtesttesttesttesttesttesttesttesttesttesttest"));
	JS::RootedId pid(cx);
	pid.set(JL_StringToJsid(cx, jsstr));

	TEST( JL_JsvalToJsid(cx, OBJECT_TO_JSVAL(JS_NewObject(cx, NULL, NULL, NULL)), &id) );
	TEST( JSID_IS_OBJECT(id) );


//	// see Bug 688510
	TEST( JS_GetParent(JS_NewObject(cx, NULL, NULL, NULL)) != NULL );
//	TEST( JS_GetParent(jl::newObjectWithGivenProto(cx, NULL, NULL, NULL)) != NULL );


	JS_ThrowStopIteration(cx);
	TEST( JL_IsStopIterationExceptionPending(cx) );
	JS_ClearPendingException(cx);


//	JL_CHK( JS_SetPropertyAttributes(cx, o, "test", 0, &found) );
//
////	jsval ok;
////	jsid pid;
////	pid = JL_StringToJsid(cx, L("test"));
////	JS_DeletePropertyById2(cx, o, pid, &ok);
//
////	JL_RemovePropertyById(cx, o, JL_StringToJsid(cx, L("test")));
//
//	JL_CHK( JS_HasProperty(cx, o, "test", &found) );
//	TEST( !found );


	// jl::Stack ////////////////////////////////////////////////////
	{
	static int STest_count = 0;
	struct STest {
		~STest() { STest_count++; }
	};
	jl::Stack<STest> stack;
	++stack;
	--stack;
	TEST( STest_count == 1 ); // test if the destructor of STest is called properly
	STest_count = 0;
	}
	/////////////////////////////////////////////////////////////////


	// Buffer ////////////////////////////////////////////////////

	{
	char *ref = (char*)jl_malloc(20000);
	for ( int i = 0; i < 20000; i++ )
		ref[i] = rand() & 0xff; // 0->255
	int refPos = 0;

	jl::ChunkedBuffer<char> b;

	for ( int i = 0; i < 100; i++ ) {

		int rnd = rand() & 0xff; // 0->127
		b.Reserve(rnd);
		char *tmp = b.Ptr();
		jl::memcpy(tmp, ref + refPos, rnd);
		b.Advance(rnd);
		refPos += rnd;
	}

	int l = b.Length();

	char *tmp = (char*)jl_malloc(l);
	b.CopyTo(tmp, l);

	const char *d = b.GetData();
	bool success = memcmp(ref, d, l) == 0 && memcmp(ref, tmp, l) == 0;
	TEST( success );

	jl_free(tmp);
	jl_free(ref);
	}


	/////////////////////////////////////////////////////////////////

	// Buffer (2) ////////////////////////////////////////////////////

	{
	jl::ChunkedBuffer<char> resultBuffer;
	resultBuffer.Reserve(10000);
	resultBuffer.Advance(10000);
	jl_free( resultBuffer.GetDataOwnership() );
	}

	/////////////////////////////////////////////////////////////////

	// JLData ///////////////////////////////////////////////////////
	{
	JLData str1("aé\x10\x1B\xFF", 1); // 97 130
	TEST( str1.GetCharAt(0) == 'a' );
	TEST( str1.GetCharAt(1) == 'é' );

	JLData str2(L("aé\x10\x1B\xFF"), 1);
	TEST( str1.GetWCharAt(0) == L('a') );
	TEST( str1.GetWCharAt(1) == L('é') );

	jschar s1[100];
	str1.CopyTo(s1);
	s1[str1.Length()] = 0;
	TEST( !wcscmp(s1, L("aé\x10\x1B\xFF") ) );

	char s2[100];
	str2.CopyTo(s2);
	s2[str2.Length()] = 0;
	TEST( !strcmp(s2, "aé\x10\x1B\xFF" ) );

	TEST( !wcscmp(str1.GetConstWStrZ(), L("aé\x10\x1B\xFF") ) );
	TEST( !strcmp(str2.GetConstStrZ(), "aé\x10\x1B\xFF" ) );
	}
	/////////////////////////////////////////////////////////////////

	// misc inlining ////////////////////////////////////////////////

	static JSObject *obj;
	size_t a = jl::GetEIP();
	{
	obj = JL_CLASS_PROTOTYPE(cx, Handle);
	JL_IGNORE(obj);
	}
	a = jl::GetEIP() - a;
	TEST( a < 200 );
	//printf("%d\n", a); exit(0);

	/////////////////////////////////////////////////////////////////

	// misc ////////////////////////////////////////////////

//	js::ArrayBuffer::create(cx, 0, NULL);
//	OBJECT_TO_JSVAL(NULL);

	/////////////////////////////////////////////////////////////////

	// ptr -> native -> ptr ///////////////////////////////////////////////////////////////

	{
	void *ptr = (void*)0; // 00...00
	
	JS::RootedValue v;
	void *tmp = ptr;
	JL_CHK( JL_NativeToJsval(cx, tmp, v) );
	JL_CHK( jl::getValue(cx, v, &tmp) );
	TEST( tmp == ptr );
	}

	{
	void *ptr = (void*)1; // 00...01
	
	JS::RootedValue v;
	void *tmp = ptr;
	JL_CHK( JL_NativeToJsval(cx, tmp, v) );
	JL_CHK( jl::getValue(cx, v, &tmp) );
	TEST( tmp == ptr );
	}

	{
	void *ptr = (void*)-1; // ff...ff
	
	JS::RootedValue v;
	void *tmp = ptr;
	JL_CHK( JL_NativeToJsval(cx, tmp, v) );
	JL_CHK( jl::getValue(cx, v, &tmp) );
	TEST( tmp == ptr );
	}

	{
	void *ptr = (void*)(size_t((void*)-1)-1); // ff...fe
	
	JS::RootedValue v;
	void *tmp = ptr;
	JL_CHK( JL_NativeToJsval(cx, tmp, v) );
	JL_CHK( jl::getValue(cx, v, &tmp) );
	TEST( tmp == ptr );
	}

	{
	void *ptr = (void*)(size_t((void*)-1) >> 1); // 7f...ff
	
	JS::RootedValue v;
	void *tmp = ptr;
	JL_CHK( JL_NativeToJsval(cx, tmp, v) );
	JL_CHK( jl::getValue(cx, v, &tmp) );
	TEST( tmp == ptr );
	}

	{
	void *ptr = (void*)((size_t((void*)-1)>>1) - 1); // 7f...fe
	
	JS::RootedValue v;
	void *tmp = ptr;
	JL_CHK( JL_NativeToJsval(cx, tmp, v) );
	JL_CHK( jl::getValue(cx, v, &tmp) );
	TEST( tmp == ptr );
	}

	/////////////////////////////////////////////////////////////////

	// JLID ///////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////
*/

	return true;
	JL_BAD;
}

#undef TEST

#endif // HAS_JL_API_TESTS




#if defined(DEBUG)  //   || 1
#define JSLANG_TEST
#endif

#ifdef JSLANG_TEST

INLINE NEVER_INLINE void
testFct( JSContext *cx ) {
	
	JL_IGNORE(cx);

//	static JS::RootedValue tmp = JSVAL_ONE;
/* 2000
	static JSObject *o = JS_NewArrayObject(cx, 0, NULL);
	JS_SetElement(cx, o, 1, &tmp); JS_SetElement(cx, o, 2, &tmp); JS_SetElement(cx, o, 3, &tmp); JS_SetElement(cx, o, 4, &tmp); JS_SetElement(cx, o, 5, &tmp); JS_SetElement(cx, o, 6, &tmp); JS_SetElement(cx, o, 7, &tmp); JS_SetElement(cx, o, 8, &tmp); JS_SetElement(cx, o, 9, &tmp); JS_SetElement(cx, o, 10, &tmp); JS_SetElement(cx, o, 11, &tmp); JS_SetElement(cx, o, 12, &tmp); JS_SetElement(cx, o, 13, &tmp); JS_SetElement(cx, o, 14, &tmp); JS_SetElement(cx, o, 15, &tmp); JS_SetElement(cx, o, 16, &tmp);
*/

/* 750
	static AutoValueVector avr(cx);
	avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp); avr.append(tmp);
*/

//	malloc(1);

}


struct TestIf {
	
	virtual int fct(int i) = 0;
};


struct Test1 : public TestIf {

	int fct(int i) {
		return i * 123;
	}
};

volatile bool test0() {
	
	return true;
}


bool test1() {

	volatile bool a = true;
	volatile bool b = true;
	volatile bool c = true;

	return a && b && c && test0();
}


bool test2() {

	volatile bool a = true;
	volatile bool b = true;
	volatile bool c = true;

	JL_CHK( a );
	JL_CHK( b );
	JL_CHK( c );
	return test0();
	JL_BAD;
}


DEFINE_FUNCTION( jslangTest ) {

	JL_IGNORE(cx, argc, vp);

	JL_DEFINE_ARGS;

/*
	jl::AutoBuffer test;

	test.alloc(2);

	((uint8_t*)test.data())[0] = 100;
	((uint8_t*)test.data())[1] = 101;

	return BlobCreate(cx, test, JL_RVAL);
*/
	{
		jl::Buf<jl::BufPartial> partBuf;
		partBuf.alloc(100);
		partBuf.setUsed(100);
		//partBuf.reinterpret<jschar, char>();
		//partBuf.reinterpret<char, jschar>();
		
		partBuf.toArrayBuffer(cx, JL_RVAL);
	}

	{
		jl::BufString str;
		str.length();
	}


	{
		jl::BufString str("test");
		str.toString<const jschar *>();
		str.toString<const char *>();
		jl_free( str.toString<char *>() );
		jl_free( str.toString<jschar *>() );
	}

	{
		jl::BufString str(L("test"));
		str.toString<const jschar *>();
		str.toString<const char *>();
		jl_free( str.toString<char *>() );
		jl_free( str.toString<jschar *>() );
	}

	{
		char *mystr = (char *)jl_malloc(5);
		strcpy(mystr, "test");
		jl::BufString str(mystr);
		str.toString<const jschar *>();
		str.toString<const char *>();
		jl_free( str.toString<char *>() );
		jl_free( str.toString<jschar *>() );
	}

	{
		jschar *mystr = (jschar *)jl_malloc(10);
		wcscpy(mystr, L("test"));
		jl::BufString str(mystr);
		str.toString<const jschar *>();
		str.toString<const char *>();
		jl_free( str.toString<char *>() );
		jl_free( str.toString<jschar *>() );
	}






	
	{
		jl::Buffer ab;
		ab.alloc(2);
		((uint8_t*)ab.data())[0] = 1;
		((uint8_t*)ab.data())[1] = 2;
		ab.toUCString(cx, JL_RVAL);
	}

/*
	{
		jl::Buffer ab;
		ab.alloc(2);
		((uint8_t*)ab.data())[0] = 100;
		((uint8_t*)ab.data())[1] = 101;
		ab.toExternalString(cx, JL_RVAL);
		bool match;
		ASSERT( JS_StringEqualsAscii(cx, JL_RVAL, "de", &match) );
		ASSERT( match );
	}
*/ 


	ASSERT( jl::tstrcmp( ("abc"), L("abc")) == 0 );
	ASSERT( jl::tstrcmp(L("abc"),  ("abc")) == 0 );

	ASSERT( jl::tstrcmp( ("abc"), L("abd")) == -1 );
	ASSERT( jl::tstrcmp(L("abc"),  ("abd")) == -1 );

	ASSERT( jl::tstrncmp(  ("abcd"), L("abce"), 3) == 0 );
	ASSERT( jl::tstrncmp( L("abcd"),  ("abce"), 3) == 0 );

	ASSERT( jl::tstrncmp( ("abcd"), L("abde"), 3) == -1 );
	ASSERT( jl::tstrncmp(L("abcd"),  ("abde"), 3) == -1 );

	ASSERT( jl::tstrncmp( ("ab"), L("abcd"), 3) != 0 );
	ASSERT( jl::tstrncmp(L("ab"),  ("abcd"), 3) != 0 );

	ASSERT( jl::tstrncmp( ("abcd"), L("ab"), 3) != 0 );
	ASSERT( jl::tstrncmp(L("abcd"),  ("ab"), 3) != 0 );

	ASSERT( jl::tstrncmp( ("abcd"), L("abc"), 3) == 0 );
	ASSERT( jl::tstrncmp(L("abcd"),  ("abc"), 3) == 0 );

	ASSERT( jl::tstrncmp( ("abc"), L("abcd"), 3) == 0 );
	ASSERT( jl::tstrncmp(L("abc"),  ("abcd"), 3) == 0 );


	JS::RootedValue rval(cx);


/*
	double d = -0;
	double e = 0;
	double f = d/e;

	ASSERT( jl::DoubleIsNeg(f) );
*/

	class X {
	public:
		static bool fct(JSContext *cx, unsigned argc, JS::Value *vp) {

			printf("C ");
			return true;
		}
	};


	JS::RootedFunction fct(cx, JS_NewFunction(cx, X::fct, 1, 0, JS::NullPtr(), "fct"));
	JS::RootedObject obj(cx, JS_GetFunctionObject(fct));
	JS::RootedValue val(cx);
	val.setObject(*obj);
	JS::RootedString str(cx, JS_NewStringCopyZ(cx, "test"));
	JS::RootedValue tmp(cx);
	tmp.setString(str);
	jl::setProperty(cx, obj, "test", val);
	JS::RootedId id(cx);
	JL_CHK( JS_ValueToId(cx, tmp, &id) );


	{

	JS::HandleObject hObj(obj);
	JS::HandleValue hVal(val);
	JS::HandleId hId(id);

	JS::MutableHandleValue mhVal(&val);
	JS::MutableHandleId mhId(&id);
	
	JS::RootedValue numval(cx);

	uint8_t uint8 = 0;
	int8_t int8 = 0;
	uint16_t uint16 = 0;
	int16_t int16 = 0;
	uint32_t uint32 = 0;
	int32_t int32 = 0;
	uint64_t uint64 = 0;
	int64_t int64 = 0;
	double dbl = 0;
	float flt = 0;

	JL_IGNORE(uint8, int8, uint16, int16, uint32, int32, uint64, int64, dbl, flt);


/*
	ASSERT( jl::fitDoubleTo(double(127), int8) );
	ASSERT( !jl::fitDoubleTo(double(128), int8) );
	ASSERT( jl::fitDoubleTo(double(0), int8) );
	ASSERT( jl::fitDoubleTo(double(-1), int8) );
	ASSERT( jl::fitDoubleTo(double(255), uint8) );
	ASSERT( !jl::fitDoubleTo(double(-1), uint8) );
	ASSERT( jl::fitDoubleTo(int32_t(-1), int32) );
	ASSERT( !jl::fitDoubleTo(int32_t(-1), uint32) );
	ASSERT( jl::fitDoubleTo(int32_t(0), int32) );
	ASSERT( jl::fitDoubleTo(int32_t(0), uint32) );
	ASSERT( jl::fitDoubleTo(int32_t(127), int8) );
	ASSERT( !jl::fitDoubleTo(int32_t(128), int8) );
	ASSERT( jl::fitDoubleTo(int32_t(127), int64) );
	ASSERT( jl::fitDoubleTo(int32_t(128), int64) );
	ASSERT( jl::fitDoubleTo(int32_t(128), uint64) );
	ASSERT( !jl::fitDoubleTo(int32_t(-128), uint64) );

	ASSERT( jl::fitInt32To(int32_t(0), flt) );
	ASSERT( jl::fitInt32To(int32_t(INT32_MAX), flt) );
	ASSERT( jl::fitInt32To(int32_t(INT32_MIN), flt) );


	ASSERT( !jl::fitInt32To(int32_t(-1), uint32) );
	ASSERT( jl::fitInt32To(int32_t(0), uint32) );
	ASSERT( jl::fitInt32To(int32_t(1), uint32) );
	ASSERT( jl::fitInt32To(int32_t(INT32_MAX), uint32) );

	ASSERT( jl::fitInt32To(int32_t(0), uint64) );
	ASSERT( jl::fitInt32To(int32_t(INT32_MAX), uint64) );
	ASSERT( !jl::fitInt32To(int32_t(INT32_MIN), uint64) );
	
	ASSERT( !jl::isIntegral(dbl) );
	ASSERT( jl::isIntegral(int8) );
*/
/*

	ASSERT((jl::JLIsInBounds<int16_t, int16_t>(int16_t(0))));
	ASSERT((jl::JLIsInBounds<int16_t, int16_t>(int16_t(INT16_MIN))));
	ASSERT((jl::JLIsInBounds<int16_t, int16_t>(int16_t(INT16_MAX))));
	ASSERT((jl::JLIsInBounds<uint16_t, uint16_t>(uint16_t(UINT16_MAX))));
	ASSERT((jl::JLIsInBounds<uint16_t, int16_t>(uint16_t(0))));
	ASSERT((!jl::JLIsInBounds<uint16_t, int16_t>(uint16_t(-1))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint16_t>(int16_t(-1))));
	ASSERT((jl::JLIsInBounds<int16_t, uint16_t>(int16_t(INT16_MAX))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint16_t>(int16_t(INT16_MIN))));
	ASSERT((jl::JLIsInBounds<int32_t, uint32_t>(int32_t(INT32_MAX))));
	ASSERT((!jl::JLIsInBounds<int32_t, uint32_t>(int32_t(INT32_MIN))));
 
	ASSERT((jl::JLIsInBounds<int16_t, int32_t>(int16_t(0))));
	ASSERT((jl::JLIsInBounds<int16_t, int32_t>(int16_t(INT16_MIN))));
	ASSERT((jl::JLIsInBounds<int16_t, int32_t>(int16_t(INT16_MAX))));
	ASSERT((jl::JLIsInBounds<uint16_t, uint32_t>(uint16_t(UINT16_MAX))));
	ASSERT((jl::JLIsInBounds<uint16_t, int32_t>(uint16_t(0))));
	ASSERT((jl::JLIsInBounds<uint16_t, int32_t>(uint16_t(-1))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint32_t>(int16_t(-1))));
	ASSERT((jl::JLIsInBounds<int16_t, uint32_t>(int16_t(INT16_MAX))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint32_t>(int16_t(INT16_MIN))));
	ASSERT((jl::JLIsInBounds<int32_t, uint64_t>(int32_t(INT32_MAX))));
	ASSERT((!jl::JLIsInBounds<int32_t, uint64_t>(int32_t(INT32_MIN))));

	ASSERT((jl::JLIsInBounds<int16_t, int8_t>(int16_t(0))));
	ASSERT((!jl::JLIsInBounds<int16_t, int8_t>(int16_t(INT16_MIN))));
	ASSERT((!jl::JLIsInBounds<int16_t, int8_t>(int16_t(INT16_MAX))));
	ASSERT((!jl::JLIsInBounds<uint16_t, uint8_t>(uint16_t(UINT16_MAX))));
	ASSERT((jl::JLIsInBounds<uint16_t, int8_t>(uint16_t(0))));
	ASSERT((!jl::JLIsInBounds<uint16_t, int8_t>(uint16_t(-1))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint8_t>(int16_t(-1))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint8_t>(int16_t(INT16_MAX))));
	ASSERT((!jl::JLIsInBounds<int16_t, uint8_t>(int16_t(INT16_MIN))));
	ASSERT((!jl::JLIsInBounds<int32_t, uint16_t>(int32_t(INT32_MAX))));
	ASSERT((!jl::JLIsInBounds<int32_t, uint16_t>(int32_t(INT32_MIN))));

	ASSERT((!jl::JLIsInBounds<int64_t, int32_t>(int64_t(INT32_MIN) - 1)));
	ASSERT((jl::JLIsInBounds<int64_t, int32_t>(int64_t(INT32_MIN))));
	ASSERT((jl::JLIsInBounds<int64_t, int32_t>(int64_t(INT32_MIN) + 1)));
	ASSERT((jl::JLIsInBounds<int64_t, int32_t>(int64_t(INT32_MAX) - 1)));
	ASSERT((jl::JLIsInBounds<int64_t, int32_t>(int64_t(INT32_MAX))));
	ASSERT((!jl::JLIsInBounds<int64_t, int32_t>(int64_t(INT32_MAX) + 1)));

	ASSERT((!jl::JLIsInBounds<int64_t, uint32_t>(int64_t(-1))));
	ASSERT((jl::JLIsInBounds<int64_t, uint32_t>(int64_t(0))));
	ASSERT((jl::JLIsInBounds<int64_t, uint32_t>(int64_t(1))));
	ASSERT((jl::JLIsInBounds<int64_t, uint32_t>(int64_t(UINT32_MAX) - 1)));
	ASSERT((jl::JLIsInBounds<int64_t, uint32_t>(int64_t(UINT32_MAX))));
	ASSERT((!jl::JLIsInBounds<int64_t, uint32_t>(int64_t(UINT32_MAX) + 1)));


	ASSERT( jl::fitsIn(double(255), uint8) );
	ASSERT( !jl::fitsIn(double(255), int8) );
	ASSERT( jl::fitsIn(double(255), uint16) );

	ASSERT( !jl::fitsIn(float(FLT_MAX), int64) );
	ASSERT( !jl::fitsIn(double(DBL_MAX), int64) );

	ASSERT( jl::fitsIn(double(255), uint8) );
	ASSERT( !jl::fitsIn(double(256), uint8) );
	ASSERT( jl::fitsIn(double(1), flt) );

	ASSERT( jl::fitsIn(double(FLT_MAX), flt) );
	ASSERT( !jl::fitsIn(double(DBL_MAX), flt) );

	ASSERT( jl::fitsIn(int64_t(INT64_MAX), flt) );
	ASSERT( jl::fitsIn(int64_t(INT64_MAX), flt) );

	ASSERT( jl::fitsIn(int64_t(INT32_MAX), int32) );
	ASSERT( jl::fitsIn(int64_t(UINT32_MAX), uint32) );

	ASSERT( jl::fitsIn(double(INT32_MIN), int32) );
	ASSERT( jl::fitsIn(float(INT32_MIN), int32) );
	ASSERT( jl::fitsIn(int64_t(INT32_MIN), int32) );
	ASSERT( jl::fitsIn(int8_t(INT8_MIN), dbl) );
	ASSERT( jl::fitsIn(int32_t(INT32_MIN), int32) );

	ASSERT( jl::fitsIn(int32, uint32) );
	ASSERT( jl::fitsIn(int32, dbl) );
*/


	ASSERT( jl::isTypeFloat64(dbl) );
	ASSERT( !jl::isTypeFloat64(flt) );
	ASSERT( jl::isTypeFloat32(flt) );
	ASSERT( !jl::isTypeFloat32(dbl) );


	JL_CHK( jl::call(cx, obj, val, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, obj, id, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, obj, fct, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, obj, "test", &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, obj, L("test"), &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	
	JL_ASSERT( jl::call(cx, hObj, val, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hObj, id, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hObj, fct, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hObj, "test", &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hObj, L("test"), &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	
	JL_ASSERT( jl::call(cx, val, val, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, val, id, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, val, fct, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, val, "test", &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, val, L("test"), &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	
	JL_ASSERT( jl::call(cx, hVal, val, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hVal, id, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hVal, fct, &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hVal, "test", &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );
	JL_ASSERT( jl::call(cx, hVal, L("test"), &rval, 1, obj, id, val, str, "foo", jl::strSpec( L("bar"), 3)) );

	JL_ASSERT( jl::setElement(cx, hVal, 0, "test") );

	JL_ASSERT( jl::setProperty(cx, obj, "TEST", 1) );
	JL_ASSERT( jl::setProperty(cx, obj, L("TEST"), 1) );
	JL_ASSERT( jl::setProperty(cx, obj, jl::strSpec("TEST", 4), 1) );
	JL_ASSERT( jl::setProperty(cx, obj, jl::strSpec(L("TEST"), 4), 1) );

	JL_ASSERT( jl::setProperty(cx, obj, "TEST", val) );
	JL_ASSERT( jl::setProperty(cx, obj, L("TEST"), val) );
	JL_ASSERT( jl::setProperty(cx, obj, jl::strSpec("TEST", 4), val) );
	JL_ASSERT( jl::setProperty(cx, obj, jl::strSpec(L("TEST"), 4), val) );

	JL_ASSERT( jl::setProperty(cx, val, "TEST", val) );
	JL_ASSERT( jl::setProperty(cx, val, L("TEST"), val) );
	JL_ASSERT( jl::setProperty(cx, val, jl::strSpec("TEST", 4), val) );
	JL_ASSERT( jl::setProperty(cx, val, jl::strSpec(L("TEST"), 4), val) );

	JL_ASSERT( jl::setProperty(cx, val, "TEST", 1) );
	JL_ASSERT( jl::setProperty(cx, val, L("TEST"), 1) );
	JL_ASSERT( jl::setProperty(cx, val, jl::strSpec("TEST", 4), 1) );
	JL_ASSERT( jl::setProperty(cx, val, jl::strSpec(L("TEST"), 4), 1) );

	{

	JL_ASSERT( jl::getProperty(cx, obj, "TEST", mhVal) );

	JL_ASSERT( jl::getProperty(cx, obj, "TEST", &int32) );

	JL_ASSERT( jl::getProperty(cx, obj, "TEST", &val) );
	JL_ASSERT( jl::getProperty(cx, obj, L("TEST"), &val) );
	JL_ASSERT( jl::getProperty(cx, obj, jl::strSpec("TEST", 4), &val) );
	JL_ASSERT( jl::getProperty(cx, obj, jl::strSpec(L("TEST"), 4), &val) );
	JL_ASSERT( jl::getProperty(cx, obj, id, &val) );
	JL_ASSERT( jl::getProperty(cx, obj, hId, &val) );

	JL_ASSERT( jl::getProperty(cx, obj, "TEST", mhVal) );
	JL_ASSERT( jl::getProperty(cx, obj, L("TEST"), mhVal) );
	JL_ASSERT( jl::getProperty(cx, obj, jl::strSpec("TEST", 4), mhVal) );
	JL_ASSERT( jl::getProperty(cx, obj, jl::strSpec(L("TEST"), 4), mhVal) );
	JL_ASSERT( jl::getProperty(cx, obj, id, mhVal) );
	JL_ASSERT( jl::getProperty(cx, obj, hId, mhVal) );



	JL_ASSERT( jl::setElement(cx, obj, 0, val) );
	JL_ASSERT( jl::setElement(cx, obj, 0, hVal) );
	JL_ASSERT( jl::setElement(cx, obj, 0, mhVal) );


	JL_ASSERT( jl::getElement(cx, obj, 0, &val) );
	JL_ASSERT( jl::getElement(cx, obj, 0, mhVal) );
	JL_ASSERT( !jl::getElement(cx, obj, 0, &int32) );


	}

//	ASSERT( !JS_IsExceptionPending(cx) );
	

	JL_ASSERT( jl::hasProperty(cx, obj, "TEST") );
	JL_ASSERT( jl::hasProperty(cx, obj, L("TEST")) );
	JL_ASSERT( jl::hasProperty(cx, obj, jl::strSpec("TEST", 4)) );
	JL_ASSERT( jl::hasProperty(cx, obj, jl::strSpec(L("TEST"), 4)) );

	JL_ASSERT( jl::hasProperty(cx, val, "TEST") );
	JL_ASSERT( jl::hasProperty(cx, val, L("TEST")) );
	JL_ASSERT( jl::hasProperty(cx, val, jl::strSpec("TEST", 4)) );
	JL_ASSERT( jl::hasProperty(cx, val, jl::strSpec(L("TEST"), 4)) );


	JL_ASSERT( jl::construct(cx, hObj) );
	JL_ASSERT( jl::construct(cx, hObj, 1) );


	jl::setVector(cx, &val, &uint8, 1);
	uint32_t act;
	jl::getVector(cx, val, &uint8, 1, &act);


	JL_ASSERT( jl::getValue(cx, numval, mhVal) );


	jl::setValue(cx, &numval, "123");
	ASSERT( numval.isString() );
	JL_ASSERT( jl::getValue(cx, numval, &uint8) );
	JL_ASSERT( jl::getValue(cx, numval, &int16) );
	JL_ASSERT( jl::getValue(cx, numval, &flt) );
	JL_ASSERT( jl::getValue(cx, numval, &dbl) );

	jl::setValue(cx, &numval, "255.1");
	JL_ASSERT( !jl::getValue(cx, numval, &uint8) );

	jl::setValue(cx, &numval, ::std::numeric_limits<double>::max());
	JL_ASSERT( !jl::getValue(cx, numval, &flt) );

	numval.setDouble(1.5);
	JL_ASSERT( jl::getValue(cx, numval, &uint8) );
	JL_ASSERT( jl::getValue(cx, numval, &int16) );
	JL_ASSERT( jl::getValue(cx, numval, &flt) );
	JL_ASSERT( jl::getValue(cx, numval, &dbl) );
	
	numval.setInt32(256);
	JL_ASSERT( jl::getValue(cx, numval, &flt) );
	JL_ASSERT( jl::getValue(cx, numval, &dbl) );
	JL_ASSERT( jl::getValue(cx, numval, &int16) );
	JL_ASSERT( !jl::getValue(cx, numval, &uint8) );
	JS_ClearPendingException(cx);

	unsigned long num = 123;
	JL_ASSERT( jl::setValue(cx, &val, num) );

	char txt[] = "sdfgsdfg";
	JL_ASSERT( jl::setValue(cx, &val, txt) );

	}



	{

	JL_ASSERT( test1() );
	JL_ASSERT( test2() );

	}


/*

	__asm { int 3 }

	JS::RootedValue test1(cx);
	__asm { nop }
	JS::RootedValue v1 = test1;
	__asm { nop }
	test1 = v1;

	__asm { nop }

	JS::MutableHandleValue test2(&test1);
	__asm { nop }
	JS::RootedValue v2 = test2;
	__asm { nop }
	test2.set(v2);
	
	JS::HandleValue test3(test2);
	JS::RootedValue v3 = test3;
	JL_IGNORE(v3);

	struct { void operator()(JS::MutableHandleValue m1) {
		
		JL_IGNORE(m1);
	} } cl1;

	cl1(test2);

	args.rval().set(test3);
*/



//	bool st = JS_IsInt8Array(obj, cx);

/*
	static uint64_t xx[2];

	__asm { int 3 }
	__asm { int 3 }
	__asm { int 3 }

	xx[1] = DOUBLE_TO_JSVAL(123).asRawBits();
	xx[2] = DOUBLE_TO_JSVAL(456).asRawBits();

	__asm { int 3 }
	__asm { int 3 }
	__asm { int 3 }

	JL_IGNORE(xx);
*/
	

/*
	JL_CHK( ::SetThreadAffinityMask(GetCurrentThread(), 1) );
	JL_CHK( ::SetProcessPriorityBoost(GetCurrentProcess(), TRUE) ); // disable dynamic boosting
	JL_CHK( ::SetPriorityClass(::GetCurrentProcess(), REALTIME_PRIORITY_CLASS) );
	JL_CHK( ::SetThreadPriority(::GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) );

	// (TBD) try to get the 'agruments' variable instead of using rootedValues ?
	// (TBD) use AutoValueVector avr(cx); avr.reserve(16); avr.append(val);

	unsigned __int64 count, min = UINT64_MAX, sum = 0;

	int i = 0;
	for (; i < 10000; ++i ) {

		count = rdtsc();
		testFct(cx);
		testFct(cx);
		testFct(cx);
		testFct(cx);
		testFct(cx);
		testFct(cx);
		testFct(cx);
		testFct(cx);
		count = (rdtsc() - count) / 8;
		sum += count;
		min = jl::min(min, count);
	}

	printf("min cycles: %I64d\n", min);
	printf("avg cycles: %I64d\n", sum/i);

	exit(0);
*/


/*
	size_t a = JLGetEIP();
	//
	a = JLGetEIP() - a;
	printf("res: %d\n", a); exit(0);



	JSObject *o = JSVAL_TO_OBJECT(*vp);

	static const void *tmp;

	size_t a = JLGetEIP();

	tmp = JL_GetCachedClassProto(JL_GetHostPrivate(cx), "Handle");
	
	a = JLGetEIP() - a;
	
	printf("%d\n", a); exit(0);
*/


/*
	//jsval constructor;
	//JS_GetProperty(cx, JS_GetGlobalObject(cx), "SyntaxError", &constructor);
	
	JSObject *proto;
	js_GetClassPrototype(cx, JS_GetGlobalObject(cx), JSProto_Error, &proto, NULL);

	JSClass *cl = JS_GetClass(proto);
*/

/*
	jsval constructor, val;

	JL_CHK( JS_GetProperty(cx, JL_GetGlobal(cx), "SyntaxError", &constructor) );
	JSObject *errorObj = JS_NewObjectForConstructor(cx, &constructor);
	//JSObject *errorObj = JS_New(cx, JSVAL_TO_OBJECT(constructor), 0, NULL);
	val = OBJECT_TO_JSVAL(errorObj);
*/



/*
	const jschar *name = L("SyntaxError");

	jsval constructor;
	JL_CHK( JS_GetUCProperty(cx, JL_GetGlobal(cx), name, wcslen(name), &constructor) );

	//JSObject *test = JS_GetConstructor(cx, JSVAL_TO_OBJECT(constructor));

	JSObject *proto = JS_GetPrototype(JSVAL_TO_OBJECT(constructor));

	JSObject *ob = JS_NewObject(cx, NULL, proto, NULL);

	JSClass *cl = JS_GetClass(ob);
	//JSObject *errorObj = JS_NewObjectForConstructor(cx, &constructor);
*/

	return true;
	JL_BAD;
}

#endif // JSLANG_TEST




#include "jlclass3.h"


/*
STATIC_CLASS()

	JL_FUNCTION( xxx, 2 ) {


		return false;
	}


CLASS_END



CLASS( test )

//	JL_PROTOTYPE( pTest )


	JL_HAS_PRIVATE

	JL_SLOT(foo)
	JL_SLOT(bar)

	JL_CONST( fooInt, 1234 )
	JL_CONST( fooDbl, 1234.5 )

	JL_CONSTRUCTOR() {
	
		return true;
	}

	JL_FUNCTION( fct1, 2 ) {

		//JL_GetReservedSlot(
		_slot_foo.index;
		printf("const:%d\n", _const_fooInt.value);
		return false;
	}



	JL_PROPERTY( status )

		JL_GETTER() {

			return true;
		}

		JL_SETTER() {

			return true;
		}
	JL_PROPERTY_END



	JL_PROPERTY( status1 )

		JL_GETTER() {

			return true;
		}

	JL_PROPERTY_END

	JL_INIT() {

		return true;
	}

CLASS_END

*/


////


DEFINE_INIT() {


	JS::RootedObject robj(cx, JL_GetGlobal(cx));

	//REGISTER_STATIC();
	REGISTER_CLASS(FooBar);
	
//	JL_CHK( _static::_classSpec.Register(cx, &robj) );

	return true;
	JL_BAD;
}



/**qa
	if ( '_jsapiTests' in global )
		_jsapiTests();

	QA.ASSERTOP( NaN, '==', NaN ); // test qa.js
	QA.ASSERTOP( NaN, '===', NaN );  // test qa.js
	QA.ASSERTOP( 1, '!=', NaN ); // test qa.js
	QA.ASSERTOP( 1, '!==', NaN );  // test qa.js

	QA.ASSERTOP( Handle._buildDate, '>', 0 );

	QA.ASSERTOP( Handle, 'has', 'prototype' );
	QA.ASSERTOP( Handle, 'has', 'constructor' );

	QA.ASSERTOP( timeoutEvents(1), 'instanceof', Handle );
	QA.ASSERTOP( timeoutEvents(1), 'has', '__proto__' );
	QA.ASSERTOP( timeoutEvents(1), 'has', 'constructor' );
**/

CONFIGURE_STATIC

//	HAS_INIT

//	REVISION(jl::SvnRevToInt("$Revision$")) // avoid to set a sourceId property to the global context.
	BEGIN_STATIC_FUNCTION_SPEC

		FUNCTION_ARGC( isCallable, 1 )
		
		FUNCTION_ARGC( stringify, 2 )
		FUNCTION_ARGC( join, 2 )
		FUNCTION_ARGC( indexOf, 3 )

		FUNCTION_ARGC( processEvents, 8 ) // (8 is just a guess)
		FUNCTION_ARGC( timeoutEvents, 2 )

		#ifdef HAS_JL_API_TESTS
		FUNCTION( _jsapiTests )
		#endif

		#ifdef JSLANG_TEST
		FUNCTION( jslangTest )
		#endif

	END_STATIC_FUNCTION_SPEC

END_STATIC



/* test for jlclass3.h

enum { status2, status3, status4 };

CLASS(EmptyClass)
CLASS_END

DOC("static class has a lot of static mumbers", "some more details...")
CLASS(FooBar)

	REV(jl::SvnRevToInt("$Revision$"))

	SLOT(bar)
	SLOT(foo)

	PROTO( Handle )

	PRIVATE {
		int i;
		int j;
	}

	// CONSTRUCTOR UNCONSTRUCTABLE
	CONSTRUCTOR NATIVE() {
		
		JL_DEFINE_ARGS;
		JL_DEFINE_CONSTRUCTOR_OBJ;
		JL_SetPrivate(obj, new config::Private);
		return true;
		JL_BAD;
	}


	FINALIZE_RET() {
			
		delete JL_GetPrivate(obj);
		return true;
	}


	DOC("state property is cool", "details about that...")
	STATIC_PROP 
		NAME( state )
		GET() {

//			printf("%d\n", SLOT_INDEX(foo));
			return true;
		}


	DOC(".status is a status prop");
	PROP
		NAME( status )
		SET() {
		
			return true;
		}


	DOC("status0 doc ...")
	PROP NAME( status0 )
		GET() {

			SLOT_INDEX(bar);
			return true;
		}
		SET() {
			return true;
		}


	CALL ARGC(0,1) NATIVE() {
		
		
		return true;
	}



	PROP
		DOC("status2 is a property")
		NAME_ID( status2 )
		
		DOC("status3 is a property")
		NAME_ID( status3 )
		
		DOC("status4 is a property")
		NAME_ID( status4 )

		GET() {
			return true;
		}

		SET() {
			return true;
		}

	

	JL_FUNCTION(yyy, 0, 1) {

		return true;
	}


	FUNC NAME(zzz) ARGC(0, 1) NATIVE() {

		_item.argcMax;

		return true;
	}


	DOC("this is a function that is named 'fct2', call it like this: fct2()");
	STATIC_FUNC
		NAME(fct2)
		ARGMIN(2)
		NATIVE() {
			
			JL_DEFINE_ARGS;

			return true;
			JL_BAD;
		}

	DOC("const1 is a constant value\n"
		"this is a 2nd line"
	)


	CONSTANT_NAME( const1, 1234.5 )

	DOC("MY_CONST is another constant")

	#define MY_CONST 789
	CONSTANT( MY_CONST )
	CONSTANT( 999 )

	CONSTANT( PATH_MAX )
	
	ITERATOR() {
	
		JS::RootedObject o(cx);
		return o;
	}


	INIT() {

		return true;
	}
	
CLASS_END

*/